# Leetcode 40

这个题目，用回溯法来做，类似于用树来做选择。最关键的一点是要去重，去重的关键逻辑是：先将数组排序，当前位置的前一个位置和当前位置的数字一样时，并且前一个位置没有被使用过的话，则跳过。如果不跳过的话，就有可能以当前位置为开头，然后出现重复的答案了，带入几个样例就很会明朗。（2，3，3，2，3，3，6）target为6。

**其实当你遇到一个问题，发现可以把这个题目的解法抽象为树结构来做的时候，就可以确定回溯法一定是一个可以ac的方法，但是如果有时间复杂度要求，那么回溯法并不一定会是一个好方法，本质上回溯法就是穷举**


#### 回溯法模板
~~~
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
~~~

**当你已经能够抽象出树结构的时候，只需要把对应的移动逻辑搞清楚，如果需要横向遍历，说明for循环应该进入下一步了，如果需要继续纵向遍历，说明应该调用递归方法了。别忘了处理过程和回溯过程是一一对应的，处理有加，回溯就要有减！**