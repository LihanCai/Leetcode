# Leetcode 1105
这个问题当时看到的时候，我的理解有些问题。简单来说，这个题目的意思就是按照顺序获取book数组中的元素，你可以决定创建新的一层书架或者将这本获得的书加入到这一层中。
利用动态规划的思想。
假设本来数组长度为x，现在加入一本书，如何获得最小长度？
即在允许范围内，倒序遍历，尽可能加入多的书籍放到同一层（当width不够的时候，停止）。然后每一次加入先前的某一本书x之后，当前的高度就等于之前的到x之前的所有的书的最小高度+本层高度。
本层高度是所有本层书籍中最高的那个。

部分代码：
for (int j = i; j >= 0; --j) {
    leftW -= books[j][0];//检测剩余长度
    if (leftW < 0)
        break;
    maxH = Math.max(maxH, books[j][1]);
    f[i + 1] = Math.min(f[i + 1], f[j] + maxH);
}

### 动态规划
1. 定义dp[i]为，到第i本book的时候，最小的高度。
2. 每一次初始化为Integer.MAX_VALUE
3. dp[i] = Math.min(dp[i],dp[j]+maxHeight)
4. 递归顺序为倒序遍历，遍历books数组。

