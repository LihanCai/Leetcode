# Leetcode 947

题目解读：给定一个数组代表各个石头的位置，若有两个石头在同一行或者同一列，则可以删除其中一个，要求返回你能删除的最多的石头数量。

看了lee神的题解，来给大家分享一下。解决该问题的思路实际上就一句话，所有相连接的石头，也就是行或者列共享的石头(island)，都能够被削减到只剩下一块石头，比如数列：{(0, 0), (0, 1), (1, 0),(1, 1)}，最终可以削减到剩下任意一个石头。我本来的想法是每次都削减共享石头数量最少的石头，这样子造成的数量减少的影响是最小的，类似于贪心的思路。
但下面这个数列，应用这个思路，我们会先删除最中间的这个点，然后就将这个链接的岛屿分成了完全分开的两个子岛屿，这样子最终你会剩下两个石头，因为你有两个没有任何石头是在同一行或者同一列的岛屿。
[[1, 1, 0, 0, 0],
[1, 1, 0, 0, 0],
[0, 1, 1, 0, 0],
[0, 0, 1, 1, 1],
[0, 0, 0, 1, 1]]

好的策略：应用dfs算法来遍历，由此，你能够确保每一个被探索到的石头都属于这个岛屿，那你就可以按照和探索的顺序相反的顺序来删除石头，最后剩下你开始dfs算法的位置的石头。这个方法能够成功的原因是,DFS算法是通过树这个数据结构来遍历的，而树能够自底向上逐个删除元素。其实到此，你已经能够解决这个问题了，用dfs找到每个共享行列的小团体，每一个小团体都能够删减到只剩一个石头，所以答案是石头个数减去island个数即可，但这个算法的时间复杂度是O(n^2)。lee神用的并查集这个数据结构来做，让时间复杂度到了O(n)，具体的实现，详见代码。